#+title: Pythonでやってはいけないやってみるべきこと
#+subtitle: PyCon Mini 東海 2025
#+author: Atsushi Odagiri
#+date: 2025-11-08
#+BEAMER_THEME: Boadilla
#+BEAMER_COLOR_THEME: seahorse
#+OPTIONS: H:2 toc:t num:t
#+OPTIONS: ^:{}
#+LaTeX_CLASS: beamer
#+LATEX_CLASS_OPTIONS: [aspectratio=169]
#+LaTeX_HEADER: \usepackage{luatexja}

* COMMENT metadata
- 20分発表
- 5分質疑応答
- スライド上限40枚くらい
  - タイトルだけのスライドもあるから45くらいまでは許容
  
* はじめに
** TODO お前誰よ
- Atsushi Odagiri
- aodag
- 株式会社オープンコレクター

** TODO 今日のお話

- ダイナミックで...フェティッシュ...ではない...
- 危険で冒険的なプログラミング

* ハックルベリーと黒魔術

** お仕事とプログラミング

- 構成管理
- 静的型チェック
- テストとかカバレージ
- レビュー
- やらなきゃいけないことがいっぱい！

** 安全で窮屈

- 助けてくれるツールたち！
  - mypy, ruff, pyright ...
- お前らに何がわかるってんだよ！

** 危険と冒険的なプログラミング

- プログラミングは楽しいんだ！
  - 作りたいものが動いたとき
  - 疑問を解消したとき
- もっとめちゃくちゃやってもいい
- 悪いことしよう

** TODO 冒険が黒魔術になるとき

- 追い詰められて手を出してしまう
- 危険に見えないようにごまかす

* become anther class なりたい自分

** TODO class への代入

- 冒険は変化を与えてくれる
- ~__class__~ を変えてみよう

* 自己import 頼れるのは自分だけ

** TODO 自分をimportするとどうなる？

- ~__main__.x~ と ~importme1.x~
- ~sys.modules~

** 自分をimportするモジュール

#+begin_src python
  #importme1.py
  import importme1

  x = 1
  print(__name__, importme1.x)
  x = 2
  print(__name__, importme1.x)
#+end_src

** 自分を見つめる誰か

#+begin_example
python importme1.py
importme1 1
importme1 2
__main__ 2
__main__ 2
#+end_example

- 最初は ~__main__~ モジュールとして実行される
- ~__main__~ から ~importme1~ をimportするのは問題なし
- その先の ~importme1~ から ~importme1~ をimportしているのは問題ない？

** 自分はもういる

- ~import~ は include ではない
- もう ~importm1~ がインタプリタ上に存在しているので、2回目以降は参照を返すだけ

** ではどこにいるか

- ~sys.modules~ を確認しよう

#+begin_src python
  # importme2.py
  import sys
  print(__name__, "いるよ！" if "importme2" in sys.modules else "いないよ！")
  import importme2
  print(__name__, "いるよ！" if "importme2" in sys.modules else "いないよ！")
#+end_src

** え、いつからいるの

#+begin_example
__main__ いないよ！
importme2 いるよ！
importme2 いるよ！
__main__ いるよ！
#+end_example

- importしたとき、そのモジュールを実行するときにはもうモジュールがsys.modulesに登録されている

** TODO 消せ！

- import中にエラーが発生する
- sys.modules から消える
- 再度importで再評価

** TODO 自己importの懸念

- 無限ループしない？
  - import時にもうインタプリタにいてそれ以上ロードされないから大丈夫！
- でもエラーがおきたらsys.modulesから消えるよね
  - Σ

** TODO 私のことを覚えておいて

#+begin_src python
  # importme3.py
  import sys
  sys.modules["ximportme3"] = sys.modules[__name__]
  raise Exception()
#+end_src

** TODO そこに私はいます

#+begin_src python
  >>> import importme3
  Traceback (most recent call last):
    File "<python-input-2>", line 1, in <module>
      import importme3
    File ".../importme3.py", line 4, in <module>
      raise Exception()
  Exception
  >>> import ximportme3
  >>> ximportme3
  <module 'importme3' from '.../importme3.py'>
#+end_src
- エラー前に自分のモジュールを別のモジュールに代入しておく

** 私は誰

#+begin_src python
  >>> sys.modules["ximportme3"] == ximportme3
  True
  >>> import importme3
  Traceback (most recent call last):
    File "<python-input-12>", line 1, in <module>
      import importme3
    File ".../importme3.py", line 4, in <module>
      raise Exception()
  Exception
  >>> sys.modules["ximportme3"] == ximportme3
  False
#+end_src

- 再度import実行するとsys.modulesに別のインスタンスとして登録される

** 無限ループできるか？

- 無限ループといえばgenerator

** モジュールよ、お前はiterableになれ

#+begin_src python
  # iterable_module.py
  def __iter__():
      yield 1
      yield 2
#+end_src

** ならない

#+begin_src python
  >>> iter(iterable_module)
  Traceback (most recent call last):
    File "<python-input-1>", line 1, in <module>
      iter(iterable_module)
      ~~~~^^^^^^^^^^^^^^^^^
  TypeError: 'module' object is not iterable
#+end_src

- ~__iter__~ を定義するだけではだめ

** TODO モジュールよ、iterableになるのを拒むな

- ~ModuleType~, ~Iterable~ を多重継承したclass
- ~__class__~ を書き換えるのはできたな！

#+begin_src python
  import sys
  from collections.abc import Iterable
  from types import ModuleType

  class IterableModule(ModuleType, Iterable):

      def __iter__(self):
          yield 1
          yield 2

  sys.modules[__name__].__class__ = IterableModule
#+end_src

** iterableなモジュール

- importして即forループ

#+begin_src python
  >>> import iterable_module
  >>> for i in iterable_module:
  ...     print(i)
  ...
  1
  2
#+end_src

** TODO yield from で再帰ジェネレーター

- ジェネレーターの先でさらにimportトリック
- ~__class__~ の書き換えも忘れずに

#+begin_src python
  class IterableModule(ModuleType, Iterable):

      def __iter__(self):
          n = __import__(__name__ + "$")
          yield self
          yield from n

  self = sys.modules[__name__]
  self.__class__ = IterableModule
  sys.modules[__name__ + "$"] = self
  raise Exception()
#+end_src


** 永遠なれ！
#+begin_src python
  >>> import iteratable_module
  Traceback (most recent call last):
    File "<python-input-3>", line 1, in <module>
      import iterable_module
    File ".../iterable_module.py", line 15, in <module>
      raise Exception()
  Exception
  >>> iterable_module = __import__("iterable_module$")
  >>> for i in iterable_module:
  ...     print(id(i), i)
#+end_src

** 無限ループって怖くね

#+begin_src python
  139818183224400 <module 'iterable_module' from '.../iterable_module.py'>
  139818183224400 <module 'iterable_module' from '.../iterable_module.py'>
    ...
  139818183224400 <module 'iterable_module' from '.../iterable_module.py'>
  139818183224400 <module 'iterable_module' from '.../iterable_module.py'>
  Traceback (most recent call last):
    File "<python-input-2>", line 1, in <module>
      for i in iterable_module:
               ^^^^^^^^^^^^^^^
    ...
    File ".../iterable_module.py", line 10, in __iter__
      yield from n
    [Previous line repeated 988 more times]
  RecursionError: maximum recursion depth exceeded
#+end_src

** TODO 最初のimportするのをどこでやるか

- pthハック

* explore frames 見てはいけない

** TODO クロージャー(レキシカルスコープ)は便利だけど

- でも！呼び出し元の状況を知りたい！


** レキシカルスコープとダイナミックスコープ

- その変数はどこの値を見るのか
#+begin_src python
  x = 1
  def f1():
      x = 2
      def f2():
          print(f"{x=}")
  def f3():
      x = 3
      f1()()
#+end_src

** 呼び出し側の変数を見る

- ~sys._getframe~
#+begin_src python
  x = 1
  def f1():
      x = 2
      def f2():
          x = sys._getframe(1).f_globals["x"]
          print(f"{x=}")
  def f3():
      x = 3
      f1()()
#+end_src


* pth hack 黒魔術はあなたのそばに

* 黒魔術について

** 役に立ちそうな気がする？

- それこそが黒魔術への扉を開く一歩目なのです

* おわりに

** 参考文献

- Python 3.14.0 documentation
  - Language Reference
