#+title: Pythonでやってはいけないやってみるべきこと
#+subtitle: PyCon Mini 東海 2025
#+author: Atsushi Odagiri
#+date: 2025-11-08
#+BEAMER_THEME: Boadilla
#+BEAMER_COLOR_THEME: seahorse
#+OPTIONS: H:2 toc:t num:t
#+OPTIONS: ^:{}
#+LaTeX_CLASS: beamer
#+LATEX_CLASS_OPTIONS: [aspectratio=169]
#+LaTeX_HEADER: \usepackage{luatexja}

* COMMENT metadata
- 20分発表
- 5分質疑応答
- スライド上限40枚くらい
  - タイトルだけのスライドもあるから45くらいまでは許容
  
* はじめに
** お前誰よ [0/1]
- Atsushi Odagiri
- aodag
- 株式会社オープンコレクター
- [ ] 画像入れる

* やってみるべきやってはいけないこと

** お仕事とプログラミング

- 構成管理
- 静的型チェック
- テストとかカバレージ
- レビュー
- やらなきゃいけないことがいっぱい！

** 安全で窮屈

- 助けてくれるツールたち！
  - mypy, ruff, pyright ...
- お前らに何がわかるってんだよ！

** 危険と冒険的なプログラミング

- プログラミングは楽しいんだ！
  - 作りたいものが動いたとき
  - 疑問を解消したとき
- もっとめちゃくちゃやってもいい
- 悪いことしよう

* 違う自分になる

** 吾輩は猫である

- オブジェクト指向の入門によくあるやつ

#+begin_src python 
  >>> class Cat:
  ...     def greet(self):
  ...         print("にゃん")
  ...         
  >>> cat = Cat()
  >>> cat.greet()
  にゃん
#+end_src

** いや、猫じゃなかった

- ~__class__~ を変えてみよう

#+begin_src python 
  >>> class Dog:
  ...     def greet(self):
  ...         print("わん")
  ...         
  >>> cat.__class__ = Dog
  >>> cat.greet()
  わん
#+end_src

** お前、変わったよな

- ~isinstance~ もそう言ってる

#+begin_src python
  >>> isinstance(cat, Cat)
  False
  >>> isinstance(cat, Dog)
  True
#+end_src

** でも覚えているよ

- 以前のクラスでのバウンドメソッドを参照

#+begin_src python
  >>> cat = Cat()
  >>> cat_greet = cat.greet
  >>> cat.__class__ = Dog
  >>> cat.greet()
  わん
  >>> cat_greet()
  にゃん
#+end_src

* 頼れるのは自分だけ

** 自分を見つめ直す

- 自分をimportするモジュール

#+begin_src python
  #importme1.py
  import importme1

  x = 1
  print(__name__, importme1.x)
  x = 2
  print(__name__, importme1.x)
#+end_src

** 実行しよう
  
#+begin_example
python importme1.py
importme1 1
importme1 2
__main__ 2
__main__ 2
#+end_example

- 最初は ~__main__~ モジュールとして実行される
- ~__main__~ から ~importme1~ をimportするのは問題なし
- その先の ~importme1~ から ~importme1~ をimportしているのは問題ない？

** え、どういうこと

- ~import~ は include ではない
- もう ~importm1~ がインタプリタ上に存在しているので、2回目以降は参照を返すだけ

** ではどこにいるか！ここにいるぞ！

- ~sys.modules~ を確認しよう

#+begin_src python
  # importme2.py
  import sys
  print(__name__, "いるよ！" if "importme2" in sys.modules else "いないよ！")
  import importme2
  print(__name__, "いるよ！" if "importme2" in sys.modules else "いないよ！")
#+end_src

** え、いつからいるの

#+begin_example
__main__ いないよ！
importme2 いるよ！
importme2 いるよ！
__main__ いるよ！
#+end_example

- importしてそのモジュールを実行するときにはもうモジュールがsys.modulesに登録されている
- 無限ループしない？
  - import時にもうインタプリタにいてそれ以上ロードされないから大丈夫！
- でもエラーがおきたらsys.modulesから消えるよね
  - Σ

** 私のことを覚えておいて

#+begin_src python
  # importme3.py
  import sys
  sys.modules["ximportme3"] = sys.modules[__name__]
  raise Exception()
#+end_src

- import中にエラーが発生する
- sys.modules から消える
- その前に別名でsys.modulesに退避しておく

** そこに私はいます

#+begin_src python
  >>> import importme3
  Traceback (most recent call last):
    File "<python-input-2>", line 1, in <module>
      import importme3
    File ".../importme3.py", line 4, in <module>
      raise Exception()
  Exception
  >>> import ximportme3
  >>> ximportme3
  <module 'importme3' from '.../importme3.py'>
#+end_src

- sys.modules にすでに存在している
- importしてもsys.moduleの参照を返すだけ
- ximportme3.py がなくてもエラーにならない

** 世の中に似ている人は3人いる

#+begin_src python
  >>> sys.modules["ximportme3"] == ximportme3
  True
  >>> import importme3
  Traceback (most recent call last):
    File "<python-input-12>", line 1, in <module>
      import importme3
    File ".../importme3.py", line 4, in <module>
      raise Exception()
  Exception
  >>> sys.modules["ximportme3"] == ximportme3
  False
#+end_src

- 再度import実行するとsys.modulesに別のモジュールインスタンスとして登録される


* 振り回す

** モジュールよ、お前はiterableになれ

#+begin_src python
  # iterable_module.py
  def __iter__():
      yield 1
      yield 2
#+end_src

- モジュールに直接 ~__iter__~ 関数を定義したらそのモジュールはiterableなのでしょうか？

** ならない

#+begin_src python
  >>> iter(iterable_module)
  Traceback (most recent call last):
    File "<python-input-1>", line 1, in <module>
      iter(iterable_module)
      ~~~~^^^^^^^^^^^^^^^^^
  TypeError: 'module' object is not iterable
#+end_src

- ~__iter__~ を定義するだけではだめ

** Iterableになれるかな？

- さあお前は今から ~Iterable~ になるんだよ！

#+begin_src python
  # be_iterable.py
  import sys
  from collections.abc import Iterable
  sys.modules[__name__].__class__ = Iterable
#+end_src

- 実行してみると

#+begin_src shell
  $ python be_iterable.py
  Traceback (most recent call last):
    File ".../be_iterable.py", line 4, in <module>
      sys.modules[__name__].__class__ = Iterable
      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  TypeError: __class__ assignment only supported for mutable types or ModuleType subclasses
#+end_src
** モジュールよ、iterableになるのを拒むな

- ~ModuleType~, ~Iterable~ を多重継承したclass
- ~__class__~ を書き換える？さっきやったな！

#+begin_src python
  import sys
  from collections.abc import Iterable
  from types import ModuleType

  class IterableModule(ModuleType, Iterable):

      def __iter__(self):
          yield 1
          yield 2

  sys.modules[__name__].__class__ = IterableModule
#+end_src

** iterableなモジュール

- importして即forループ

#+begin_src python
  >>> import iterable_module
  >>> for i in iterable_module:
  ...     print(i)
  ...
  1
  2
#+end_src

** TODO yield from で再帰ジェネレーター

- ジェネレーターの先でさらにimportトリック
- ~__class__~ の書き換えも忘れずに

#+begin_src python
  class IterableModule(ModuleType, Iterable):

      def __iter__(self):
          n = __import__(__name__ + "$")
          yield self
          yield from n

  self = sys.modules[__name__]
  self.__class__ = IterableModule
  sys.modules[__name__ + "$"] = self
  raise Exception()
#+end_src


** 永遠なれ！
#+begin_src python
  >>> import iteratable_module
  Traceback (most recent call last):
    File "<python-input-3>", line 1, in <module>
      import iterable_module
    File ".../iterable_module.py", line 15, in <module>
      raise Exception()
  Exception
  >>> iterable_module = __import__("iterable_module$")
  >>> for i in iterable_module:
  ...     print(id(i), i)
#+end_src

** 無限ループって怖くね

#+begin_src python
  139818183224400 <module 'iterable_module' from '.../iterable_module.py'>
  139818183224400 <module 'iterable_module' from '.../iterable_module.py'>
    ...
  139818183224400 <module 'iterable_module' from '.../iterable_module.py'>
  139818183224400 <module 'iterable_module' from '.../iterable_module.py'>
  Traceback (most recent call last):
    File "<python-input-2>", line 1, in <module>
      for i in iterable_module:
               ^^^^^^^^^^^^^^^
    ...
    File ".../iterable_module.py", line 10, in __iter__
      yield from n
    [Previous line repeated 988 more times]
  RecursionError: maximum recursion depth exceeded
#+end_src

* explore frames 見てはいけない

** レキシカルスコープとダイナミックスコープ

- その変数はどこの値を見るのか
- でも！呼び出し元の状況を知りたい！

#+begin_src python
  x = 1
  def f1():
      x = 2
      def f2():
          print(f"{x=}")
  def f3():
      x = 3
      f1()()
#+end_src

** 呼び出し側の変数を見る

- ~sys._getframe~
#+begin_src python
  x = 1
  def f1():
      x = 2
      def f2():
          x = sys._getframe(1).f_globals["x"]
          print(f"{x=}")
  def f3():
      x = 3
      f1()()
#+end_src


* COMMENT 入り切らない

# 置いてはいけないものを置く
- `__main__.py`
- 危険な便利さとは
- `__init__.py`

* 見てはいけないものを見る

** double undersocre name mangling

#+begin_src python
  >>> class F:
  ...     def __init__(self):
  ...         self.__x = 1
  ...
  >>> f = F()
  >>> f.__x
  Traceback (most recent call last):
    File "<python-input-7>", line 1, in <module>
      f.__x
  AttributeError: 'F' object has no attribute '__x'
  >>> dir(f)
  ['_F__x', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__firstlineno__', '__format__', '__ge__', '__getattribute__', '__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__static_attributes__', '__str__', '__subclasshook__', '__weakref__']
  >>> f._F__x
  1
#+end_src

** 見える

- _{クラス名}__x のようにクラス名を追加するだけなので簡単に見える
- double undersocre name mangling は private にするためではない
- 親クラスと子クラスで名前の衝突を避けるためのもの

** 見えないようにする

- クロージャーの中でクラス定義すると？

#+begin_src python
  >>> def F():
  ...     class F:
  ...         def m(self):
  ...             return x
  ...     x = 1
  ...     return F()
  ...
  >>> f = F()
  >>> f.m()
  1
  >>> dir(f)
  ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__firstlineno__', '__format__', '__ge__', '__getattribute__', '__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__static_attributes__', '__str__', '__subclasshook__', '__weakref__', 'm']
#+end_src
** 見えないな！
- そもそもオブジェクトの属性ではない
- クラスの属性でもない
- クロージャーの中で変数としてしか存在してない

#+begin_src python
  >>> f.x
  Traceback (most recent call last):
    File "<python-input-19>", line 1, in <module>
      f.x
  AttributeError: 'F' object has no attribute 'x'
  >>> F.x
  Traceback (most recent call last):
    File "<python-input-23>", line 1, in <module>
      F.x
  AttributeError: 'function' object has no attribute 'x'
#+end_src

** 見えないものを見る

- inspectモジュールで奥深くまで！
- getclosurevarsを使えばクロージャーにバインドされている変数も見える

#+begin_src python
  >>> inspect.getclosurevars(f.m).nonlocals["x"]
  1
#+end_src
** 冒険が黒魔術になるとき

- 追い詰められて手を出してしまう
- 危険に見えないようにごまかす


* おわりに

** やってみるべきこと

- ふとした疑問を試してみる
- さらに疑問を投げかける
- 黒魔術との境に気をつける
- 黒魔術に気づく

** やってはいけないこと

- 試したことをそのまま公の場に出す
- 武勇伝
  - 今やってるじゃないか

** 参考文献

- Python 3.14.0 documentation
  - Library
  - Language Reference
